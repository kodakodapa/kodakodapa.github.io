---
layout: post
title: "Thoughts about http API:s for web development"
date: 2025-10-25
author: Bj√∂rn
---

I've used and created a bunch of web API:s over the years, below are some thoughts about REST (**RE**presentational **S**tate **T**ransfer) and the rest. 

## Richardson maturity model for REST

I think an OK starting point is this model. For someone used to REST-like APIs it's a good reminder that REST isn't necessary on the web, and especially in the past there used to be other types of APIs. This model divides the *maturity* of  APIs into four levels, depedning on how REST-full they are. The levels use 0-indexing:

- **Level 0:** Use e.g. POST for everything and supply instructions in the POST:ed data. E.g. "lookup resource y", "delete x,z", "lock this thing" and use one URL. The response works similarly, e.g. bunch of XML back that you have to know how to make sense of. Errors aren't communicated via HTTP codes instead in the resource you get back, and everything has e.g. status code 200. Typicall called `RPC` (Remote Procedure Call)
- **Level 1:** Here we do a minor step by introducing more sensible URLs. E.g. `/appointments` for stuff related to that, `/users` for stuff related to that and so on instead of one or only a few master URLs. Other than that it's similar to level 0, using RPCs.
- **Level 2:** On this level you make use of all the HTTP verbs (`PUT/PATCH/POST/GET/DELETE`) and you use HTTP status codes to communicate the state of the request (forbidden, conflict, created, ok, server error etc etc). Core to this level is also using resource oriented URLs, e.g. `/users/:id` where `id` is an identifier for a specific user. You can also include caching headers on this level, allowing `GET` to be cached as appropriate
- **Level 3:** This one I've seen a few times - the idea is that you use HATEOAS (Hypertext As The Engine Of Application State). If you say create a resoruce then the API also replies with URI:s/URL:s for further interaction with the resource and the system itself, instructing the user which actions are possible for the resoruce. As a developer or a client you can then discover the system and its capabilities by inspecting the links in the answers, in fact the idea is that the server defines what's possible and the client doesn't need to know what's possible to do next.



### Thoughts about the model

- **Level 0:** I've come across this level when programming `SOAP` APIs for POS (**P**oint **O**f **S**ale) terminals. Honestly I think it's kind of OK. Or, the OK:ness depends on how well this RPC API is made, not on the fact that it doesn't use REST.
- **Level 1:** I don't think I've come across this level as stated. What I have come across quite a few times is level 1.5 however. You use *some* HTTP verbs, but RPC mixed in. And you use only a few status codes, but never any "bad" ones (400+), for these you always include an error field wrapped in a HTTP 200. That's the worst kind of API IMO since concepts are so mixed and everything is so hard to understand and debug. 
- **Level 2:** Nowadays this is usually the level I come across and the level I typically write APIs on. It's good enough for client/server communcation. Using resource oriented URLs, proper HTTP verbs and proper status codes make the APIs much easier to understand and in time easier to write and maintain. 

   Apparently Richardson called this level the most practical one, and I agree.

- **Level 3:** I have come across this one a few times. These includes API driven products such as those provided by PSPs (**P**ayment **S**ervice **P**roviders). In these cases I did somewhat appreciate the self-documenting part of the APIs, but more as a developer playing around with the responses to understand and troubleshoot. I would however still lookup API specifications and write client code with baked in static knowledge over state transitions and so on in the API (although for convenience I would sometimes grab a resource URL in the respone which I knew would be present). So in the end even for this larger type of system where the API is at the center of the product I at least didn't use it to its potential, and I don't see how it could have been useful actually. As a consumer of the API the difficulty in supporting the dozens or so payment flows I had to handle didn't lie in API and resource discovery.

   I've also come across this level in some internal system APIs for smaller backend applications where some developers have been ambitious. In these cases it has really been overkill and a lot of time and resources was wasted on making sure the system adhered to the specification, whilst giving minimal benefit to the few users building a handful of FE features using the system.

   I have to say it also - HATEOAS is a really ugly acronym.

### In conclusion, in my opinion
If you're creating REST-like APIs the sweetspot is adhering to level 2. Being lazy and doing some REST stuff but not full level 2 makes it confusing and ugly, and trying to be so fancy that you have to use the acronomyn HATEOAS is probably a big waste of time. 

On the other hand, if you wanna use a mature well written SOAP service then that's also fine, but don't use it for common web development that's the land of REST (and GraphQL)